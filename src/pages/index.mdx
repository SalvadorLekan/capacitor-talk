---
title: Cross Platform UI development using Capacitor.
author: Salvador AbdulRahman
layout: ../layouts/Layout.astro
---

import appAndroid from "../assets/setup-android.png";
import appIOS from "../assets/setup-ios.png";

<title>{frontmatter.title}</title>

# {frontmatter.title}

## Introduction

<span lang="jp" translate="no">
  „Åì„Çì„Å∞„Çì„ÅØ„ÄÅÁöÜ„Åï„Çì„ÄÇÁßÅ„ÅÆÂêçÂâç„ÅØ„Äå„Çµ„É´„Éê„Éâ„Éº„É´„Äç„Åß„Åô„ÄÇ
</span>

Good evening Everyone, I am Salvador, a frontend engineer here at Rise. I am currently on the Assetbase team doing great stuff.

Part of the great stuff that I've done was converting the Assetbase web app to mobile app installable from the stores. Which is why we are here today.

## Background: Cross platform

- As software engineers, there's an expectation that our code should run on or target multiple platforms.
- As backend engineers, it may be making sure that your code runs on major operating systems and cloud providers
- As mobile engineers, it may mean writing building softwares that runs on the mobile platforms
- For web engineers, it may be ensuring consistency accross different browsers and viewports.

### Cross-platform UI development

Java's tagline resonates with a lot of UI engineers who want their code to translate to as much platforms as they can get as each platform have their specification for developing UIs.

> Java's tagline is "Write Once, run Anywhare" because of the rich OS/platforms support that JVM provide forn running the generated bytecode.

A lot of effort has gone into cross-platform over the years, example of tools like that are:

- [Flutter by Google](https://flutter.dev/): A cross platform UI framework for building desktop, mobile and web apps by creating and extending UI widget using the `Dart` programming language.
- [React Native by Facebook](https://reactnative.dev/): A cross platform UI framework for building mobile apps using JSX and JavaScript, it can also create desktop and web apps.
- [Kotlin Multiplatform (and Compose Multiplatform) by JetBrains](https://www.jetbrains.com/kotlin-multiplatform/): A new mover in the cross platform UI race using `Kotlin` as the language of choice.
- [.NET Multi-platform App UI by Microsoft](https://dotnet.microsoft.com/en-us/apps/maui): Microsoft's spin to writing native apps in `C#` and `XML`

These tools provide an interface that translates to what the target platforms can render.

What if we want to build apps using web technologies? It may be because we already have a web solution that works, because we are more comfortable with using web technology or for any other reason.

For that we have:

- Progressive Web Apps (PWAs): This is the standard offering of the web, it allows a web app to run in a stand-alone window with it's own name and icon. It can even appear in your list of applications in some operating systems. It can also be bundled to the Google, Microsoft and App stores.
- [Electron](https://www.electronjs.org/): Powering Desktop apps like Slack, VS Code, Figma. It ships Node and Chromium, and also empowers developers with native desktop capabilities.
- [Capacitor by Ionic](https://capacitorjs.com/): Convert Existing Web app codebase to a mobile app.

## Capacitor: The intro

### What is Capacitor?

Capacitor is a tool that converts a web app into a mobile app.

It does that by serving the directory containing the web assets in a Webview, It then adds a native bridge that allows for communication between the web app running and the native functionality available on the target platform.

![How capacitor works](https://capacitorjs.jp/assets/img/blog/how-capacitor-works/zoomed.png)

### Why use capacitor?

Capacitor extends the functionalities possible on the web by providing intermediate access to native APIs through core plugins or community provided ones.
You can write your own plugins too.

## Capacitor 2: The set up. Assetbase as a case study.

The capacitor docs explains how to [set up capacitor](https://capacitorjs.com/docs/getting-started#add-capacitor-to-your-web-app) on an existing.

We will do that using the [Assetbase Repo](https://github.com/risevest/assetbase-ui)

Let's start by cloning a copy of the repo

```sh
# Clone the project from Github into ab-demo directory
git clone git@github.com:risevest/assetbase-ui.git ab-demo
# Change directory into the folder
cd ab-demo
# Install dependencies
yarn
```

Next up, We add the capacitor dependencies

```sh
# Add the CLI tools that gets things done for us.
yarn add --dev @capacitor/cli
# Add the core plugin and platform specific functionality
yarn add @capacitor/core @capacitor/android @capacitor/ios
```

Let's initialize a capicitor config, this asks you some questions about the project.

```sh
yarn cap init
```

This will create a `capacitor.config.ts` file that look like this

```ts title="capacitor.config.ts
import type { CapacitorConfig } from "@capacitor/cli";

const config: CapacitorConfig = {
  appId: "package.identifier",
  appName: "App name",
  webDir: "dist",
};

export default config;
```

Let's add platforms.

```sh
yarn cap add android
yarn cap add ios
```

We are done done with the set up.

To run the code natively we need to do three things.

Note that these three things have to happen every time you make changes to your codebase.

1. Compile our code
2. Sync the changes to the native end
3. Run/Build the native code

### Compile our code

This is the part where we generate the web directory.

In our case that's running `yarn build`

```sh
yarn build
```

### Sync the changes to the native end

This is the part where capacitor syncs our changes to the ntive end.

This needs to be done when

- We run a new build
- We update the `capacitor.config.ts` file
- We add a new plugin

```sh
yarn cap sync
```

You can also sync only a specific platform

```sh
yarn cap sync android
# Or iOS
yarn cap sync ios
```

### Run/Build the native code

To run your code you need to have Android studio (for Andorod) and Xcode (for iOS).

```sh title="Run Android"
yarn cap run android
```

```sh title="Run iOS"
yarn cap run ios
```

I personally prefer to open Android studio/Xcode to run things.

```sh title="Open Android Studio"
yarn cap open android
```

```sh title="Open Xcode"
yarn cap open ios
```

Whichever path you pick is up to you.

üéâ Our set up is done

## Capacitor 3: The quirks

<img src={appIOS.src} width={appIOS.width} height={appIOS.height} alt="" />
<br />
<br />
<img src={appAndroid.src} width={appAndroid.width} height={appAndroid.height} alt="" />

After successfully running the apps, you will notice that the ios app takes up the whole and some contents are blocked by the staus bar, notch and home indicator.

On android, using the native back navigation minimizes the app no matter where you are on the app.

Let's start by fixing the android quirk.

```sh
# Install the Capacitor App plugin
yarn add @capacitor/app
# Sync the change
yarn cap sync
```

Run the code on Android again and the quirk should be gone.

The fix for the iOS quirk is to move our content to the safe area.

There are many ways to solve this, I went with adding more padding to the layout, drawers and the header(s).

We first need to inform the browser (webview) of the situation. We do that by telling it that our content is going to cover the viewport.

```html del={2} ins={3-6} title="index.html"
...
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0" />
<meta name="viewport" content="viewport-fit=cover, width=device-width, initial-scale=1.0, maximum-scale=1.0" />
...
```

The webview is kind enough to compute CSS environment variables for the safe area

We would then need to update the spacing to account for the safe area.

For example:

```css del={2} ins={3}
.app-layout {
  padding-top: 1.5rem;
  padding-top: calc(env(safe-area-inset-top) + 1.5rem);
}
```

This works, but one problem; we styled in tailwind.

```tsx del={1} ins={2}
<div className="... pt-6 ...">
<div className="... pt-[calc(env(safe-area-inset-top)+1.5rem)] ...">
</div>
```

I don't want to write an epistle as a class name.

I decided to write a tailwind plugin for it.

```js title="tailwind.config.js" del={3} ins={4-18}
const plugin = require('tailwindcss/plugin')
...
plugins: [],
plugins: [
   plugin(function ({ matchUtilities, theme }) {
     matchUtilities(
       {
         'pt-safe': (value) => ({
           paddingTop: `calc(env(safe-area-inset-top) + ${value})`,
         }),
         'pb-safe': (value) => ({
           paddingBottom: `calc(env(safe-area-inset-bottom) + ${value})`,
         }),
       },
       { values: theme('spacing') }
     )
   }),
 ],
```

Revisiting the change would be

```tsx del={1} ins={2} "safe-"
<div className="... pt-6 ...">
<div className="... pt-safe-6 ...">
</div>
```

Now the app is within the safe area.

Now we have bundled it as a mobile app ü•≥

I changed the App icons and sent the build to the stores.

üéä The app is ready for alpha release.

## Capacitor 4: The tweak requests.

We invited the product team at Assetbase to give it a run.

Then came the tweak requests.

- Woah, Splash screen is missing, We definitely need that!
- Can we have onboarding carousel screens?
- Can we have a bottom navigation but only on the mobile app?
- The header and the side drawer makes it feel like a web app, can we change it?
- The fonts are too big/bold on the wallet page, can we change that? we should restyle icon buttons while at it. The change should only affect the mobile app of course.

The designer provided the designs for the changes (Great guy).

### Splash screen is missing?

Ionic provides a great VScode extension that allows you to generate a your splash screen and app icon amongst other things.

Capacitor also provides a CLI package to generate the splash scren and app icon (It's what the extension uses).

After you set up the splash screen files, Capacitor provides an official `@capacitor/splash-screen` plugin to control the behaviour of your Splash screen such as the duration, you can also manually open or close the splash screen from your web app (if you need to).

```sh
yarn add @capacitor/splash-screen
# And you are good to go!
```

### Now for the UI changes

The capacitor core plugin provides utility to the determine what platform you are running on.

```ts title="src/app-constants/index.ts"
import { Capacitor } from "@capacitor/core";

export const IS_NATIVE_APP = Capacitor.isNativePlatform();

export const PLATFORM = Capacitor.getPlatform();
```

With this I can now do

```tsx
import { IS_NATIVE_APP, PLATFORM } from "app-constants";
import BottomNav from "./bottom_nav";

{
  IS_NATIVE_APP && <BottomNav links={navigationLinks} />;
}

// Or Call a plaform specific action

if ((PLATFORM = "android")) {
  await App.exitApp();
}
```

Adding native logic is a breeze. But conditional styling using this would make the code unmaintainable _fast_

For example:

```tsx del={3} ins={4-7}
import { IS_NATIVE_APP } from "app-constants";

<div className="bg-primary px-2 py-1 rounded-full">
<div className={`bg-primary ${ IS_NATIVE_APP ?
  "px-4 py-2 rounded-md" :
  "px-2 py-1 rounded-full"
  }`}>
</div>
```

So I needed a way to make `CSS` aware of the platform so that I can conditionally style from within `CSS`

The solution? tell `CSS` the platform and conditionally style based on that.

```tsx title="App.tsx" "data-platform" "data-is-native"
import { IS_NATIVE_APP, PLATFORM } from "app-constants";

// Add a data-platform attribute to the <html> element
document.documentElement.dataset.platform = PLATFORM;
// Also add data-is-native attribute
document.documentElement.dataset.isNative = IS_NATIVE_APP;
```

Now we can access that from CSS

```scss
.dummy-class {
  padding-block: 0.5rem;

  &:is([data-platform="ios"] *) {
    background-color: cyan;
  }

  &:is([data-is-native="true"] *):active {
    opacity: 50%;
  }
}
```

Because we mostly use TailwindCSS, I wrote a wrote a tailwind plugin.

```js title="tailwind.config.js" ins={3-8}
const plugin = require("tailwindcss/plugin");

plugin(function ({ addVariant }) {
  addVariant("web", '&:is([data-platform="web"] *)');
  addVariant("native", '&:is([data-is-native="true"] *)');
  addVariant("ios", '&:is([data-platform="ios"] *)');
  addVariant("android", '&:is([data-platform="android"] *)');
});
```

Now I can do:

```tsx del={3} ins={4} " native:px-4 native:py-2 native:rounded-md"
import { IS_NATIVE_APP } from "app-constants";

<div className="bg-primary px-2 py-1 rounded-full">
<div className="bg-primary px-2 py-1 rounded-full native:px-4 native:py-2 native:rounded-md">
</div>
```

So I completed the tweaks and the whole world became happier.

## Capacitor 4: The feature requests

After making the UI changes and the world became a better place,

As the economist will say _"Human wants are insatiable"_ . Feature requests to include native functionality started coming in.

- Deep linking
- I want to login with Face ID
- We need realtime push notification
- We should prompt our users for rating
- We should prompt our users to update their apps

We are not going to talk about these were set up on this presentation.

If you want to know more about about these were set up, you can send me a direct message on slack.

## Capacitor 5: The questions

Do you have questions, observations, or feedback? Now's a good time to ask.

You can also send a direct message on Slack.

## Capacitor 6: The end

<span lang="jp">„Åì„Çå„ÅßÁµÇ„Çè„Çä„Å†</span>
